"""Property-based tests using Hypothesis for Blinter.

These tests use property-based testing to verify invariants and edge cases
across a wide range of inputs automatically generated by Hypothesis.
"""

# pylint: disable=too-many-lines

from pathlib import Path
import tempfile
from typing import Dict, List, Optional, Set

from hypothesis import HealthCheck, assume, given, settings, strategies as st
import pytest

from blinter import (
    RULES,
    BlinterConfig,
    LintIssue,
    Rule,
    RuleSeverity,
    _check_cmd_case_consistency,
    _check_goto_labels,
    _check_if_statement_formatting,
    _check_path_syntax,
    _check_unquoted_variables,
    _collect_indented_lines,
    _collect_labels,
    _collect_set_variables,
    _detect_line_endings,
    _find_single_line_mixed_indent,
    _has_multibyte_chars,
    _is_command_in_safe_context,
    _is_comment_line,
    _is_truly_executable_command,
    _line_makes_code_reachable,
    _parse_suppression_comments,
    _set_min_severity,
    _update_paren_depth,
    find_batch_files,
    group_issues,
    lint_batch_file,
)

# ============================================================================
# Custom Strategies for Batch File Testing
# ============================================================================


@st.composite
def rule_severity_strategy(draw: st.DrawFn) -> RuleSeverity:
    """Generate valid RuleSeverity enum values."""
    return draw(st.sampled_from(list(RuleSeverity)))


@st.composite
def rule_code_strategy(draw: st.DrawFn) -> str:
    """Generate valid rule codes (E001-E999, W001-W999, etc.)."""
    prefix = draw(st.sampled_from(["E", "W", "S", "P", "SEC"]))
    if prefix == "SEC":
        number = draw(st.integers(min_value=1, max_value=99))
        return f"{prefix}{number:03d}"
    number = draw(st.integers(min_value=1, max_value=999))
    return f"{prefix}{number:03d}"


@st.composite
def rule_strategy(draw: st.DrawFn) -> Rule:
    """Generate valid Rule instances."""
    code = draw(rule_code_strategy())
    name = draw(st.text(min_size=1, max_size=100).filter(lambda x: x.strip()))
    severity = draw(rule_severity_strategy())
    explanation = draw(st.text(min_size=1, max_size=500).filter(lambda x: x.strip()))
    recommendation = draw(st.text(min_size=1, max_size=500).filter(lambda x: x.strip()))

    return Rule(
        code=code,
        name=name,
        severity=severity,
        explanation=explanation,
        recommendation=recommendation,
    )


@st.composite
def lint_issue_strategy(draw: st.DrawFn) -> LintIssue:
    """Generate valid LintIssue instances."""
    line_number = draw(st.integers(min_value=1, max_value=10000))
    rule = draw(rule_strategy())
    context = draw(st.text(max_size=500))

    return LintIssue(line_number=line_number, rule=rule, context=context)


@st.composite
def blinter_config_strategy(draw: st.DrawFn) -> BlinterConfig:
    """Generate valid BlinterConfig instances."""
    recursive = draw(st.booleans())
    show_summary = draw(st.booleans())
    max_line_length = draw(st.integers(min_value=80, max_value=500))

    # Generate sets of rule codes
    enabled_rules: Optional[Set[str]] = None
    disabled_rules: Optional[Set[str]] = None

    if draw(st.booleans()):
        enabled_rules = draw(st.sets(rule_code_strategy(), max_size=10))

    if draw(st.booleans()):
        disabled_rules = draw(st.sets(rule_code_strategy(), max_size=10))

    min_severity = draw(st.none() | rule_severity_strategy())

    return BlinterConfig(
        recursive=recursive,
        show_summary=show_summary,
        max_line_length=max_line_length,
        enabled_rules=enabled_rules,
        disabled_rules=disabled_rules,
        min_severity=min_severity,
    )


@st.composite
def batch_line_strategy(draw: st.DrawFn) -> str:
    """Generate plausible batch file lines."""
    line_types = [
        "comment",
        "echo",
        "set",
        "if",
        "for",
        "call",
        "goto",
        "label",
        "rem",
        "empty",
        "command",
    ]
    line_type = draw(st.sampled_from(line_types))

    # Use a dictionary to map line types to their generators
    def gen_set() -> str:
        var = draw(st.text(min_size=1, max_size=20).filter(lambda x: x.isalnum()))
        val = draw(st.text(max_size=50))
        return f"SET {var}={val}"

    generators = {
        "comment": lambda: f"REM {draw(st.text(max_size=100))}",
        "echo": lambda: f"ECHO {draw(st.text(max_size=100))}",
        "set": gen_set,
        "if": lambda: "IF EXIST test.txt ECHO File exists",
        "for": lambda: "FOR %%i IN (*.txt) DO ECHO %%i",
        "call": lambda: "CALL :subroutine",
        "goto": lambda: "GOTO end",
        "label": lambda: f":{draw(st.text(min_size=1, max_size=20).filter(lambda x: x.isalnum()))}",
        "rem": lambda: f":: {draw(st.text(max_size=100))}",
        "empty": lambda: "",
        "command": lambda: draw(st.text(max_size=100)),
    }

    return generators[line_type]()


# ============================================================================
# Data Class Property Tests
# ============================================================================


class TestRuleProperties:
    """Property-based tests for Rule dataclass."""

    @given(rule=rule_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_rule_creation_valid(self, rule: Rule) -> None:
        """Valid rules should be created successfully."""
        assert isinstance(rule, Rule)
        assert rule.code
        assert rule.name
        assert isinstance(rule.severity, RuleSeverity)
        assert rule.explanation
        assert rule.recommendation

    @given(
        code=st.one_of(st.none(), st.just("")),
        rule=rule_strategy(),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_rule_invalid_code(
        self,
        code: Optional[str],
        rule: Rule,
    ) -> None:
        """Rules with invalid codes should raise ValueError."""
        with pytest.raises(ValueError, match="Rule code must be a non-empty string"):
            Rule(
                code=code if code is not None else "",
                name=rule.name,
                severity=rule.severity,
                explanation=rule.explanation,
                recommendation=rule.recommendation,
            )

    @given(
        code=rule_code_strategy(),
        severity=rule_severity_strategy(),
        explanation=st.text(min_size=1, max_size=500),
        recommendation=st.text(min_size=1, max_size=500),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_rule_invalid_name(
        self,
        code: str,
        severity: RuleSeverity,
        explanation: str,
        recommendation: str,
    ) -> None:
        """Rules with invalid names should raise ValueError."""
        with pytest.raises(ValueError, match="Rule name must be a non-empty string"):
            Rule(
                code=code,
                name="",
                severity=severity,
                explanation=explanation,
                recommendation=recommendation,
            )


class TestLintIssueProperties:
    """Property-based tests for LintIssue dataclass."""

    @given(issue=lint_issue_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_lint_issue_creation_valid(self, issue: LintIssue) -> None:
        """Valid lint issues should be created successfully."""
        assert isinstance(issue, LintIssue)
        assert issue.line_number >= 1
        assert isinstance(issue.rule, Rule)

    @given(
        line_number=st.integers(max_value=0),
        rule=rule_strategy(),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_lint_issue_invalid_line_number(self, line_number: int, rule: Rule) -> None:
        """Lint issues with invalid line numbers should raise ValueError."""
        with pytest.raises(ValueError, match="Line number must be positive"):
            LintIssue(line_number=line_number, rule=rule, context="")


class TestBlinterConfigProperties:
    """Property-based tests for BlinterConfig dataclass."""

    @given(config=blinter_config_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_config_creation_valid(self, config: BlinterConfig) -> None:
        """Valid configs should be created successfully."""
        assert isinstance(config, BlinterConfig)
        assert isinstance(config.recursive, bool)
        assert isinstance(config.show_summary, bool)
        assert config.max_line_length >= 80

    @given(config=blinter_config_strategy(), rule_code=rule_code_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_config_is_rule_enabled_consistency(
        self, config: BlinterConfig, rule_code: str
    ) -> None:
        """Rule enablement should be consistent with configuration."""
        result = config.is_rule_enabled(rule_code)
        assert isinstance(result, bool)

        # If rule is explicitly disabled, it should return False (disabled takes precedence)
        if config.disabled_rules and rule_code in config.disabled_rules:
            assert result is False
        # If enabled_rules is not empty and rule is in it (and not disabled), should be True
        elif config.enabled_rules and rule_code in config.enabled_rules:
            assert result is True

    @given(config=blinter_config_strategy(), severity=rule_severity_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_config_should_include_severity_consistency(
        self, config: BlinterConfig, severity: RuleSeverity
    ) -> None:
        """Severity filtering should be consistent."""
        result = config.should_include_severity(severity)
        assert isinstance(result, bool)

        # If no min_severity is set, all severities should be included
        if config.min_severity is None:
            assert result is True


# ============================================================================
# String Parsing Property Tests
# ============================================================================


class TestStringParsingProperties:
    """Property-based tests for string parsing functions."""

    @given(line=st.text())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_is_comment_line_deterministic(self, line: str) -> None:
        """_is_comment_line should always return the same result for the same input."""
        result1 = _is_comment_line(line)
        result2 = _is_comment_line(line)
        assert result1 == result2
        assert isinstance(result1, bool)

    @given(line=st.text())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_is_command_in_safe_context_deterministic(self, line: str) -> None:
        """_is_command_in_safe_context should be deterministic."""
        result1 = _is_command_in_safe_context(line)
        result2 = _is_command_in_safe_context(line)
        assert result1 == result2
        assert isinstance(result1, bool)

    @given(line=st.text())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_is_truly_executable_command_deterministic(self, line: str) -> None:
        """_is_truly_executable_command should be deterministic."""
        result1 = _is_truly_executable_command(line)
        result2 = _is_truly_executable_command(line)
        assert result1 == result2
        assert isinstance(result1, bool)

    @given(line=st.text())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_line_makes_code_reachable_deterministic(self, line: str) -> None:
        """_line_makes_code_reachable should be deterministic."""
        result1 = _line_makes_code_reachable(line)
        result2 = _line_makes_code_reachable(line)
        assert result1 == result2
        assert isinstance(result1, bool)

    @given(
        line=st.text(),
        current_depth=st.integers(min_value=0, max_value=10),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_update_paren_depth_bounded(self, line: str, current_depth: int) -> None:
        """_update_paren_depth should return reasonable values."""
        result = _update_paren_depth(line, current_depth)
        assert isinstance(result, int)
        # Depth shouldn't change drastically (by more than 1)
        assert abs(result - current_depth) <= 1


# ============================================================================
# Collection and Analysis Property Tests
# ============================================================================


class TestCollectionProperties:
    """Property-based tests for collection functions."""

    @given(lines=st.lists(batch_line_strategy(), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_collect_labels_returns_valid_dict(self, lines: List[str]) -> None:
        """_collect_labels should return a dict mapping labels to line numbers."""
        labels, issues = _collect_labels(lines)
        assert isinstance(labels, dict)
        assert isinstance(issues, list)

        # All keys should be strings
        for key in labels:
            assert isinstance(key, str)

        # All values should be positive integers
        for value in labels.values():
            assert isinstance(value, int)
            assert value >= 1

        # All issues should be LintIssue instances
        for issue in issues:
            assert isinstance(issue, LintIssue)

    @given(lines=st.lists(batch_line_strategy(), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_collect_set_variables_returns_valid_set(self, lines: List[str]) -> None:
        """_collect_set_variables should return a set of variable names."""
        variables = _collect_set_variables(lines)
        assert isinstance(variables, set)

        # All elements should be strings
        for var in variables:
            assert isinstance(var, str)

    @given(lines=st.lists(batch_line_strategy(), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_parse_suppression_comments_returns_valid_dict(self, lines: List[str]) -> None:
        """_parse_suppression_comments should return a dict of line numbers to rule codes."""
        suppressions = _parse_suppression_comments(lines)
        assert isinstance(suppressions, dict)

        # All keys should be integers
        for key in suppressions:
            assert isinstance(key, int)

        # All values should be sets of strings
        for value in suppressions.values():
            assert isinstance(value, set)
            for rule_code in value:
                assert isinstance(rule_code, str)

    @given(lines=st.lists(st.text(), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_collect_indented_lines_returns_valid_list(self, lines: List[str]) -> None:
        """_collect_indented_lines should return a list of tuples."""
        result = _collect_indented_lines(lines)
        assert isinstance(result, list)

        # All elements should be tuples of (int, str)
        for item in result:
            assert isinstance(item, tuple)
            assert len(item) == 2
            assert isinstance(item[0], int)
            assert isinstance(item[1], str)
            assert item[0] >= 1

    @given(lines=st.lists(st.text(), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_has_multibyte_chars_returns_valid_tuple(self, lines: List[str]) -> None:
        """_has_multibyte_chars should return (bool, list of int)."""
        has_multibyte, line_numbers = _has_multibyte_chars(lines)
        assert isinstance(has_multibyte, bool)
        assert isinstance(line_numbers, list)

        # All elements should be integers
        for line_num in line_numbers:
            assert isinstance(line_num, int)
            assert line_num >= 1


# ============================================================================
# Checking Function Property Tests
# ============================================================================


class TestCheckingFunctionProperties:
    """Property-based tests for checking functions."""

    @given(
        stripped=st.text(max_size=200),
        line_num=st.integers(min_value=1, max_value=10000),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_check_goto_labels_returns_list(self, stripped: str, line_num: int) -> None:
        """_check_goto_labels should return a list of LintIssue."""
        labels: Dict[str, int] = {}
        result = _check_goto_labels(stripped, line_num, labels)
        assert isinstance(result, list)
        for issue in result:
            assert isinstance(issue, LintIssue)
            assert issue.line_number == line_num

    @given(
        stripped=st.text(max_size=200),
        line_num=st.integers(min_value=1, max_value=10000),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_check_if_statement_formatting_returns_list(self, stripped: str, line_num: int) -> None:
        """_check_if_statement_formatting should return a list of LintIssue."""
        result = _check_if_statement_formatting(stripped, line_num)
        assert isinstance(result, list)
        for issue in result:
            assert isinstance(issue, LintIssue)
            assert issue.line_number == line_num

    @given(
        stripped=st.text(max_size=200),
        line_num=st.integers(min_value=1, max_value=10000),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_check_path_syntax_returns_list(self, stripped: str, line_num: int) -> None:
        """_check_path_syntax should return a list of LintIssue."""
        result = _check_path_syntax(stripped, line_num)
        assert isinstance(result, list)
        for issue in result:
            assert isinstance(issue, LintIssue)
            assert issue.line_number == line_num

    @given(
        stripped=st.text(max_size=200),
        line_num=st.integers(min_value=1, max_value=10000),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_check_unquoted_variables_returns_list(self, stripped: str, line_num: int) -> None:
        """_check_unquoted_variables should return a list of LintIssue."""
        result = _check_unquoted_variables(stripped, line_num)
        assert isinstance(result, list)
        for issue in result:
            assert isinstance(issue, LintIssue)
            assert issue.line_number == line_num

    @given(lines=st.lists(batch_line_strategy(), min_size=1, max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_check_cmd_case_consistency_returns_list(self, lines: List[str]) -> None:
        """_check_cmd_case_consistency should return a list of LintIssue."""
        result = _check_cmd_case_consistency(lines)
        assert isinstance(result, list)
        for issue in result:
            assert isinstance(issue, LintIssue)

    @given(indented_lines=st.lists(st.tuples(st.integers(min_value=1), st.text()), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_find_single_line_mixed_indent_returns_list(
        self, indented_lines: List[tuple[int, str]]
    ) -> None:
        """_find_single_line_mixed_indent should return a list of LintIssue."""
        result = _find_single_line_mixed_indent(indented_lines)
        assert isinstance(result, list)
        for issue in result:
            assert isinstance(issue, LintIssue)


# ============================================================================
# File Operation Property Tests
# ============================================================================


class TestFileOperationProperties:
    """Property-based tests for file operations."""

    @given(recursive=st.booleans())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_find_batch_files_returns_list(self, recursive: bool) -> None:
        """find_batch_files should return a list of Path objects."""
        # Create a temporary directory
        with tempfile.TemporaryDirectory() as tmpdir:
            result = find_batch_files(tmpdir, recursive=recursive)
            assert isinstance(result, list)
            for path in result:
                assert isinstance(path, Path)

    @given(issues=st.lists(lint_issue_strategy(), max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_group_issues_returns_dict(self, issues: List[LintIssue]) -> None:
        """group_issues should return a defaultdict mapping severity to issues."""
        result = group_issues(issues)
        assert isinstance(result, dict)

        # All keys should be RuleSeverity
        for key in result.keys():
            assert isinstance(key, RuleSeverity)

        # All values should be lists of LintIssue
        for value in result.values():
            assert isinstance(value, list)
            for issue in value:
                assert isinstance(issue, LintIssue)

    def test_detect_line_endings_with_temp_files(self) -> None:
        """_detect_line_endings should handle files with various line endings."""
        line_endings = ["\r\n", "\n", "\r"]

        for ending in line_endings:
            with tempfile.NamedTemporaryFile(mode="wb", suffix=".bat", delete=False) as tmp:
                content = f"@ECHO OFF{ending}ECHO test{ending}".encode("utf-8")
                tmp.write(content)
                tmp_path = tmp.name

            try:
                result = _detect_line_endings(tmp_path)
                assert isinstance(result, tuple)
                assert len(result) == 5
                ending_type, has_crlf, crlf_count, lf_count, cr_count = result
                assert isinstance(ending_type, str)
                assert isinstance(has_crlf, bool)
                assert isinstance(crlf_count, int)
                assert isinstance(lf_count, int)
                assert isinstance(cr_count, int)
            finally:
                Path(tmp_path).unlink()


# ============================================================================
# Configuration Property Tests
# ============================================================================


class TestConfigurationProperties:
    """Property-based tests for configuration functions."""

    @given(severity_str=st.sampled_from(["ERROR", "WARNING", "STYLE", "SECURITY", "PERFORMANCE"]))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_set_min_severity_valid(self, severity_str: str) -> None:
        """_set_min_severity should handle valid severity strings."""
        config = BlinterConfig()
        _set_min_severity(config, severity_str)
        assert config.min_severity is not None
        assert isinstance(config.min_severity, RuleSeverity)

    @given(
        severity_str=st.text().filter(
            lambda x: x.upper() not in ["ERROR", "WARNING", "STYLE", "SECURITY", "PERFORMANCE"]
        )
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_set_min_severity_invalid(self, severity_str: str) -> None:
        """_set_min_severity should not crash on invalid severity strings."""
        assume(severity_str.upper() not in ["ERROR", "WARNING", "STYLE", "SECURITY", "PERFORMANCE"])
        config = BlinterConfig()
        # Should not raise an exception, just log a warning
        _set_min_severity(config, severity_str)
        # min_severity should remain None for invalid input
        assert config.min_severity is None


# ============================================================================
# Integration Property Tests
# ============================================================================


class TestIntegrationProperties:
    """Integration property-based tests."""

    @given(
        lines=st.lists(batch_line_strategy(), min_size=1, max_size=20),
        extension=st.sampled_from([".bat", ".cmd"]),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None, max_examples=20)
    def test_lint_batch_file_with_generated_content(self, lines: List[str], extension: str) -> None:
        """lint_batch_file should handle generated batch file content."""
        content = "\r\n".join(lines)

        with tempfile.NamedTemporaryFile(
            mode="w", suffix=extension, delete=False, encoding="utf-8", newline=""
        ) as tmp:
            tmp.write(content)
            tmp_path = tmp.name

        try:
            result = lint_batch_file(tmp_path)
            assert isinstance(result, list)
            for issue in result:
                assert isinstance(issue, LintIssue)
                assert issue.line_number >= 1
        finally:
            Path(tmp_path).unlink()

    @given(rule_code=st.sampled_from(list(RULES.keys())))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_all_rules_are_valid(self, rule_code: str) -> None:
        """All rules in RULES dict should be valid Rule instances."""
        rule = RULES[rule_code]
        assert isinstance(rule, Rule)
        assert rule.code == rule_code
        assert isinstance(rule.severity, RuleSeverity)
        assert rule.name
        assert rule.explanation
        assert rule.recommendation


# ============================================================================
# Edge Case Property Tests
# ============================================================================


class TestEdgeCaseProperties:
    """Property-based tests for edge cases."""

    @given(line=st.text(alphabet=st.characters(blacklist_categories=("Cs",)), max_size=1000))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_parsing_functions_handle_unicode(self, line: str) -> None:
        """Parsing functions should handle unicode without crashing."""
        # These should not raise exceptions
        _is_comment_line(line)
        _is_command_in_safe_context(line)
        _is_truly_executable_command(line)
        _line_makes_code_reachable(line)

    @given(lines=st.lists(st.text(max_size=10), max_size=0))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_collection_functions_handle_empty_lists(self, lines: List[str]) -> None:
        """Collection functions should handle empty lists gracefully."""
        assert len(lines) == 0

        labels, issues = _collect_labels(lines)
        assert isinstance(labels, dict)
        assert isinstance(issues, list)

        variables = _collect_set_variables(lines)
        assert isinstance(variables, set)

        suppressions = _parse_suppression_comments(lines)
        assert isinstance(suppressions, dict)

    @given(
        line=st.text(
            alphabet=st.characters(
                whitelist_categories=("Lu", "Ll", "Nd", "Zs"),
                whitelist_characters="@%:()[]{}=<>|&^!",
            ),
            max_size=500,
        )
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_check_functions_dont_crash_on_valid_chars(self, line: str) -> None:
        """Check functions should handle lines with typical batch characters."""
        line_num = 1
        labels: Dict[str, int] = {}

        # These should not raise exceptions
        _check_goto_labels(line, line_num, labels)
        _check_if_statement_formatting(line, line_num)
        _check_path_syntax(line, line_num)
        _check_unquoted_variables(line, line_num)

    @given(
        lines=st.lists(
            st.text(max_size=200).filter(lambda x: "\0" not in x),
            min_size=1,
            max_size=20,
        )
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None, max_examples=10)
    def test_lint_batch_file_handles_various_content(self, lines: List[str]) -> None:
        """lint_batch_file should handle various content without crashing."""
        content = "\r\n".join(lines)

        with tempfile.NamedTemporaryFile(
            mode="w", suffix=".bat", delete=False, encoding="utf-8", newline=""
        ) as tmp:
            tmp.write(content)
            tmp_path = tmp.name

        try:
            # Should not raise an exception
            result = lint_batch_file(tmp_path)
            assert isinstance(result, list)
        finally:
            Path(tmp_path).unlink()


# ============================================================================
# Invariant Property Tests
# ============================================================================


class TestInvariantProperties:
    """Tests for invariants that should always hold."""

    @given(config=blinter_config_strategy(), rule_code=rule_code_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_disabled_rules_always_disabled(self, config: BlinterConfig, rule_code: str) -> None:
        """If a rule is in disabled_rules, it should always return False."""
        if config.disabled_rules is None:
            config.disabled_rules = set()
        config.disabled_rules.add(rule_code)
        assert config.is_rule_enabled(rule_code) is False

    @given(config=blinter_config_strategy(), rule_code=rule_code_strategy())
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_enabled_rules_override_disabled(self, config: BlinterConfig, rule_code: str) -> None:
        """Disabled rules should take precedence over enabled rules."""
        if config.disabled_rules is None:
            config.disabled_rules = set()
        if config.enabled_rules is None:
            config.enabled_rules = set()

        config.disabled_rules.add(rule_code)
        config.enabled_rules.add(rule_code)

        # Disabled should take precedence
        assert config.is_rule_enabled(rule_code) is False

    @given(issues=st.lists(lint_issue_strategy(), min_size=1, max_size=50))
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_group_issues_preserves_all_issues(self, issues: List[LintIssue]) -> None:
        """group_issues should preserve all issues without loss."""
        grouped = group_issues(issues)

        # Count total issues in grouped
        total_grouped = sum(len(issue_list) for issue_list in grouped.values())
        assert total_grouped == len(issues)

    @given(
        issues=st.lists(lint_issue_strategy(), min_size=1, max_size=50),
        severity=rule_severity_strategy(),
    )
    @settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)
    def test_group_issues_correct_severity(
        self, issues: List[LintIssue], severity: RuleSeverity
    ) -> None:
        """Issues grouped by severity should have the correct severity."""
        # Create issues with specific severity
        specific_issues = []
        for issue in issues:
            new_issue = LintIssue(
                line_number=issue.line_number,
                rule=Rule(
                    code=issue.rule.code,
                    name=issue.rule.name,
                    severity=severity,
                    explanation=issue.rule.explanation,
                    recommendation=issue.rule.recommendation,
                ),
                context=issue.context,
            )
            specific_issues.append(new_issue)

        grouped = group_issues(specific_issues)

        # All issues should be in the correct severity group
        assert len(grouped[severity]) == len(specific_issues)
        for issue in grouped[severity]:
            assert issue.rule.severity == severity
